var toArray = function _toArray(arr) {
	var ret = [];
	for (var i = 0, len = arr.length; i < len; i++) {
		ret[i] = arr[i];
	}
	return ret;
};

var Stack = {
	/*
		constructor: Generates a new middleware stack

		@arguments: Array - an array of middleware functions or stacks

		@return Stack
	*/
	constructor: function _constructor() {
		this._stack = [];
		var middlewares = toArray(arguments);
		middlewares.forEach((function (middleware) {
			this.use(middleware);
		}).bind(this));
	},
	/*
		convert an express-style piece of middleware and use it

		@param Function f - an express-style function
	*/
	express: function _express(f) {
		this.use(function (req, res) {
			if (f.length === 3 || this.errors.length === 0) {
				f.call(null, req, res, this.next);
			} else if (f.length === 4) {
				f.call(null, this.errors[0], req, res, this.next);
			}
		});
	},
	/*
		have the stack handle some data

		Examples: 

			stack.handle({
				data: [req, res],
				floor: next
			});

		@param Object hash - a hash of information
		 	{
		 		Array data - an array of data to pass to middlewares
		 		Function ceil - a ceiling function for the stack,
		 			this will be called first
		 		Function floor - a floor function for the stack,
		 			this will be called last	
		 	}
	*/
	handle: function _handle(hash) {
		hash = hash || {};

		var data = hash.data,
			stack = toArray(this._stack),
			errors = [],
			store = Object.create(this);

		hash.ceil && stack.unshift(hash.ceil);
		hash.floor && stack.push(hash.floor);

		(function _next() {
			var handler = stack.shift();

			if (arguments.length) {
				errors = errors.concat.apply(errors, arguments);
			};

			if (typeof handler === "function" && !handler.handle) {
				store.next = _next;
				store.errors = errors;
				store.floor = hash.floor;
				handler = handler.apply(store, data);
			}

			if (handler && handler.handle) {
				handler.handle({
					data: data,
					floor: Stack.passErrorsTo(_next)
				});
			}
		})();
	},
	/*
		Passes the errors to a function. Returns a new piece of middleware
			that will pass on the last argument (array of errors) to the
			passed function

		@param Function next - function to pass errors to

		@return Function
	*/
	passErrorsTo: function _passErrorsTo(next) {
		return function _floor() {
			next.apply(null, this.errors);
		};
	},
	/*
		Calls an asynchronous function with some data, then stores the first
			non-error parameter on this under the passed key.

		It will also send any errors to next

		@param Object options - a hash of dat
			{
				Function fun - async function to invoke
				Array args - args to invoke function with, the cb
					for the async functions gets appended to the 
					end of args
				String key - key to store data returned from fun
					on this
				Function cb - optional cb, will be called instead 
					of this.next
				Object context - optional context, fun will be 
					called with this context
			}
	*/
	storeData: function _storeData(options) {
		options.args.push((function _callback(err, data) {
			if (Error.prototype.isPrototypeOf(err)) {
				return this.next(err);
			} else if (err) {
				this[options.key] = err;
			} else {
				this[options.key] = data;
			}
			(options.cb || this.next).call(this);
		}).bind(this));
		options.fun.apply(options.context || null, options.args);
	},
	/*
		Add a piece of middleware to the stack

		@param Function|Stack middleware - a middleware stack or function to add
	*/
	use: function _use(middleware) {
		this._stack.push(middleware);
	}
};

module.exports = Stack;